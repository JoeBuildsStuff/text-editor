name: Deploy on push to main
on:
  push:
    branches: [main]

env:
  APP_DIR: /home/joe/apps/text-editor
  SERVICE_NAME: text-editor

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (metadata only)
        uses: actions/checkout@v4

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          BETTER_AUTH_URL: ${{ secrets.BETTER_AUTH_URL }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: APP_DIR,SERVICE_NAME,BETTER_AUTH_SECRET,BETTER_AUTH_URL
          script_stop: true
          script: |
            set -euo pipefail
            APP_DIR="${APP_DIR:-/home/joe/apps/text-editor}"
            SERVICE_NAME="${SERVICE_NAME:-text-editor}"
            cd "$APP_DIR"

            # Ensure repo is up to date
            if [ ! -d .git ]; then
              echo "Error: $APP_DIR is not a git repo" >&2
              exit 1
            fi
            # Fetch latest changes and reset to main branch
            # Use FETCH_HEAD to avoid ambiguous refname issues
            git fetch origin main
            git checkout -B main FETCH_HEAD
            git reset --hard FETCH_HEAD
            echo "Deployed commit: $(git rev-parse HEAD)"
            echo "Commit message: $(git log -1 --pretty=%B)"

            # Check if using Docker Compose - if so, Docker handles all building
            if [ -f docker-compose.yml ] && (command -v docker-compose >/dev/null 2>&1 || (command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1)); then
              # Ensure required env vars are present for docker-compose variable expansion
              if [ -z "${BETTER_AUTH_SECRET:-}" ]; then
                echo "Error: BETTER_AUTH_SECRET is not set; required by docker-compose.yml" >&2
                exit 1
              fi
              if [ -z "${BETTER_AUTH_URL:-}" ]; then
                echo "Error: BETTER_AUTH_URL is not set; required by docker-compose.yml" >&2
                exit 1
              fi
              echo "Detected Docker Compose - rebuilding and restarting container"
              # Dockerfile handles all build steps (deps, better-sqlite3, Next.js build)
              if command -v docker-compose >/dev/null 2>&1; then
                docker-compose build --no-cache text-editor 2>&1
                docker-compose up -d text-editor 2>&1
              else
                docker compose build --no-cache text-editor 2>&1
                docker compose up -d text-editor 2>&1
              fi
              echo "✓ Docker container rebuilt and restarted"
            else
              # Build directly on VPS (non-Docker deployment)
              # corepack enable skipped to avoid EACCES on symlink in /usr/bin
              if ! command -v pnpm >/dev/null 2>&1; then
                echo "pnpm not found on server; please install pnpm" >&2
                exit 1
              fi
              
              # Clean + rebuild the correct way
              echo "Cleaning node_modules, .pnpm, and .next directories"
              rm -rf node_modules .pnpm .next .next.lock 2>/dev/null || true

              # Install deps
              echo "Installing dependencies"
              pnpm install --frozen-lockfile
              
              # Manually build better-sqlite3 native bindings
              # pnpm v10 may block scripts even with onlyBuiltDependencies, so we build manually
              echo "Building better-sqlite3 native bindings"
              BETTER_SQLITE3_DIR=$(find node_modules/.pnpm -type d -path "*/better-sqlite3@*/node_modules/better-sqlite3" 2>/dev/null | head -n 1)
              if [ -n "$BETTER_SQLITE3_DIR" ] && [ -d "$BETTER_SQLITE3_DIR" ]; then
                echo "Found better-sqlite3 at: $BETTER_SQLITE3_DIR"
                cd "$BETTER_SQLITE3_DIR"
                # Run the install script to build native bindings
                # Using npm run install will execute the install script without reinstalling deps
                if command -v npm >/dev/null 2>&1; then
                  echo "Running npm install script to build native bindings..."
                  npm run install 2>&1 || npm install --ignore-scripts=false 2>&1 || true
                elif command -v node-gyp >/dev/null 2>&1; then
                  echo "Building with node-gyp..."
                  node-gyp rebuild
                else
                  # Try using pnpm exec to run node-gyp
                  echo "Building with pnpm exec node-gyp..."
                  pnpm exec node-gyp rebuild || true
                fi
                cd "$APP_DIR"
              else
                echo "Warning: better-sqlite3 directory not found, trying pnpm rebuild" >&2
                pnpm rebuild better-sqlite3 2>&1 || true
              fi

              # Verify the binding exists
              BINDING_PATH=$(find node_modules/.pnpm/better-sqlite3@*/node_modules/better-sqlite3/build/Release -name "better_sqlite3.node" 2>/dev/null | head -n 1)
              if [ -n "$BINDING_PATH" ] && [ -f "$BINDING_PATH" ]; then
                echo "✓ Verified better-sqlite3 native binding exists at: $BINDING_PATH"
              else
                echo "✗ Warning: better-sqlite3 native binding not found at expected location" >&2
                echo "  Searched in: node_modules/.pnpm/better-sqlite3@*/node_modules/better-sqlite3/build/Release/" >&2
                # Don't exit here, let the build attempt continue - it will fail with a clearer error if needed
              fi

              # Build the application
              # VPS has limited RAM (2GB), so we skip type checking to save memory
              echo "Building application directly on VPS (skipping type check on memory-constrained VPS)"
              export NODE_OPTIONS="--max-old-space-size=1536"
              export SKIP_TYPE_CHECK=true
              pnpm build

              # Restart service (try system service, then user service)
              if command -v systemctl >/dev/null 2>&1; then
                if sudo -n systemctl status "$SERVICE_NAME" >/dev/null 2>&1; then
                  echo "Restarting system service $SERVICE_NAME"
                  sudo -n systemctl restart "$SERVICE_NAME"
                elif systemctl --user status "$SERVICE_NAME" >/dev/null 2>&1; then
                  echo "Restarting user service $SERVICE_NAME"
                  systemctl --user restart "$SERVICE_NAME"
                else
                  echo "Warning: service $SERVICE_NAME not found. Skipping restart." >&2
                fi
              else
                echo "systemctl not found; skipping restart" >&2
              fi
            fi

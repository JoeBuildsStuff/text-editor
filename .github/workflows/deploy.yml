name: Deploy on push to main
on:
  push:
    branches: [main]

env:
  APP_DIR: /home/joe/apps/text-editor
  SERVICE_NAME: text-editor

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (metadata only)
        uses: actions/checkout@v4

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: APP_DIR,SERVICE_NAME
          script_stop: true
          script: |
            set -euo pipefail
            APP_DIR="${APP_DIR:-/home/joe/apps/text-editor}"
            SERVICE_NAME="${SERVICE_NAME:-text-editor}"
            cd "$APP_DIR"

            # Ensure repo is up to date
            if [ ! -d .git ]; then
              echo "Error: $APP_DIR is not a git repo" >&2
              exit 1
            fi
            # Fetch latest changes and reset to main branch
            # Use FETCH_HEAD to avoid ambiguous refname issues
            git fetch origin main
            git checkout -B main FETCH_HEAD
            git reset --hard FETCH_HEAD
            echo "Deployed commit: $(git rev-parse HEAD)"
            echo "Commit message: $(git log -1 --pretty=%B)"

            # Rebuild and restart Docker Compose (keeps Traefik-routed container in sync)
            if ! command -v docker >/dev/null 2>&1; then
              echo "Docker not found on server; cannot rebuild container" >&2
              exit 1
            fi

            echo "Building and restarting docker compose stack"
            docker compose pull text-editor || true
            docker compose build --pull text-editor
            docker compose up -d --remove-orphans text-editor

            # TODO: add a post-deploy hook that runs any pending sql/migrations/*.sql
            # files so schema changes ship automatically with the app

            echo "Disk usage before prune:"
            docker system df || true

            # Clean all unused build cache - Docker cache is content-based, not time-based
            # If inputs are the same, Docker reuses cache regardless of age
            # If inputs changed, we need new cache anyway, so old unused cache is just wasted space
            echo "Pruning all unused Docker build cache"
            docker builder prune -af || true

            # Remove all unused images (including untagged/dangling images from previous builds)
            # Keep only the currently tagged and running images
            echo "Pruning all unused Docker images (including untagged builds)"
            docker image prune -af || true

            # Clean up stopped containers (keep last hour for debugging)
            echo "Pruning stopped containers older than 1 hour"
            docker container prune -f --filter "until=1h" || true

            # Volumes are persistent data, only clean very old unused ones
            echo "Pruning unused Docker volumes older than 7 days"
            docker volume prune -f --filter "until=168h" || true

            echo "Disk usage after prune:"
            docker system df || true
